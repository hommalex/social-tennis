<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Social Tuesday Tennis</title>
    
    <link rel="stylesheet" href="bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <link rel="stylesheet" href="./mystyle.css">

    <script src="./vue3.js"></script>
    
    <script src="./components/TabSelection.js"></script>
    <script src="./components/TabGames.js"></script>
    <script src="./components/TabResult.js"></script>

</head>
<body>

<div id="app">
 <!-- -->
    <div v-if="isLoading" class="loading-overlay">
	
	  <div class="tennis-spinner-handle" role="status">
		<svg viewBox="0 0 100 100" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
		  
		  <g transform="rotate(45, 50, 50)">
			<ellipse cx="50" cy="20" rx="15" ry="20" stroke="currentColor" stroke-width="4" fill="none"/>
			
			<line x1="50" y1="40" x2="50" y2="80" stroke="currentColor" stroke-width="4" />
			
			<line x1="42" y1="10" x2="42" y2="30" stroke="currentColor" stroke-width="1" />
			<line x1="58" y1="10" x2="58" y2="30" stroke="currentColor" stroke-width="1" />
			<line x1="38" y1="20" x2="62" y2="20" stroke="currentColor" stroke-width="1" />
		  </g>
		  
		  <g transform="rotate(-45, 50, 50)">
			<ellipse cx="50" cy="20" rx="15" ry="20" stroke="currentColor" stroke-width="4" fill="none"/>
			<line x1="50" y1="40" x2="50" y2="80" stroke="currentColor" stroke-width="4" />
			<line x1="42" y1="10" x2="42" y2="30" stroke="currentColor" stroke-width="1" />
			<line x1="58" y1="10" x2="58" y2="30" stroke="currentColor" stroke-width="1" />
			<line x1="38" y1="20" x2="62" y2="20" stroke="currentColor" stroke-width="1" />
		  </g>
		  
		</svg>
		<span class="sr-only" style="position:absolute; width:1px; height:1px; overflow:hidden; clip:rect(0,0,0,0);">Loading...</span>
	  </div>
	
    </div>

    <nav class="navbar navbar-expand-lg navbar-dark bg-primary mb-4">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">
				<img src="./NavanLogo.png" style="height: 32px" alt="logo" />
				Social Tuesday Tennis
			</a>
            <div class="d-flex">
                <button class="btn btn-sm btn-outline-light" @click="fetchData">Refresh Data</button>
            </div>
        </div>
    </nav>

    <div class="container">
        <ul class="nav nav-tabs mb-4">
            <li class="nav-item" v-for="(tab, index) in tabs" :key="index">
                <a class="nav-link" :class="{ active: currentTab === tab.component }" href="#" @click.prevent="currentTab = tab.component">
                    {{ tab.name }}
                </a>
            </li>
        </ul>

        <div class="card border-primary mb-3">
            <div class="card-body">
                <transition name="fade" mode="out-in">
	
                    <component 
                        :is="currentTab" 
                        :data="jsonData"
                        :selected="selectedPlayers"
						:dialog="dialog"
                        @update-selected="updateSelectedPlayers"
                        @save-new-player="saveNewPlayer"
						@edit-player="handleEditPlayer"
						@update-games="saveGames"
						@substitute-player="handleSubstitutePlayer"
						@finalize-session="handleFinalizeSession"
                    ></component>
                </transition>
            </div>
        </div>
    </div>
			
	<div v-if="modalState.show" class="modal custom-modal-backdrop">
		<div class="modal-dialog">
			<div class="modal-content shadow">
				<div class="modal-header" :class="modalState.type === 'confirm' ? 'bg-warning text-dark' : 'bg-primary text-white'">
					<h5 class="modal-title">{{ modalState.title }}</h5>
					<button type="button" class="btn-close" @click="resolveModal(false)"></button>
				</div>
				<div class="modal-body">
					<p class="fs-6">{{ modalState.message }}</p>
				</div>
				<div class="modal-footer">
					<button v-if="modalState.type === 'confirm'" type="button" class="btn btn-secondary" @click="resolveModal(false)">Cancel</button>
					<button type="button" class="btn" :class="modalState.type === 'confirm' ? 'btn-warning' : 'btn-primary'" @click="resolveModal(true)">
						{{ modalState.type === 'confirm' ? 'Confirm' : 'OK' }}
					</button>
				</div>
			</div>
		</div>
	</div>
</div>

<script>
    const { createApp, ref, computed, reactive, onMounted } = Vue;

    const JSONBIN_CONFIG = {
        binId: '6970c321d0ea881f407a7bab', 
        apiKey: '$2a$10$8czTg3UoYIs/26B9Scbo3OkkGrZz4ZZwfrNUl./r65HzhLfzw2YU2'
    };

    createApp({
        components: {
            'tab-selection': TabSelection,
            'tab-games': TabGames,
            'tab-result': TabResult
        },
        setup() {
            const currentTab = ref('tab-selection');
            const isLoading = ref(false);
            
            const jsonData = ref({
                last_update: "",
                current: { numOfRounds: 3, list: [], games: [] },
                players: [] 
            });

            const selectedPlayers = ref([]);

            const tabs = [
                { name: 'Players', component: 'tab-selection' },
                { name: 'Matches', component: 'tab-games' },
                { name: 'Result', component: 'tab-result' }
            ];
			
			// --- MODAL LOGIC ---
            const modalState = reactive({
                show: false,
                title: '',
                message: '',
                type: 'alert', // 'alert' or 'confirm'
                resolve: null
            });
			// The function we pass to children
            const dialog = {
                alert: (title, message) => {
                    return new Promise((resolve) => {
                        modalState.title = title;
                        modalState.message = message;
                        modalState.type = 'alert';
                        modalState.show = true;
                        modalState.resolve = resolve;
                    });
                },
                confirm: (title, message) => {
                    return new Promise((resolve) => {
                        modalState.title = title;
                        modalState.message = message;
                        modalState.type = 'confirm';
                        modalState.show = true;
                        modalState.resolve = resolve;
                    });
                }
            };

            const resolveModal = (result) => {
                modalState.show = false;
                if (modalState.resolve) {
                    modalState.resolve(result);
                    modalState.resolve = null;
                }
            };

            const fetchData = async () => {
                isLoading.value = true;
                try {
                    const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_CONFIG.binId}/latest`, {
                        method: 'GET',
                        headers: { 'X-Master-Key': JSONBIN_CONFIG.apiKey }
                    });
                    const result = await response.json();
                    jsonData.value = result.record; 
                    
                    // We check if jsonData.current.list has IDs, and find the matching objects in jsonData.players
                    if (jsonData.value.current && Array.isArray(jsonData.value.current.list)) {
                         const currentIds = jsonData.value.current.list;
                         selectedPlayers.value = jsonData.value.players.filter(p => currentIds.includes(p.id));
                    }

                } catch (error) {
                    console.error("Error fetching data:", error);
                    alert("Error loading data from JSONBin.");
                } finally {
                    isLoading.value = false;
                }
            };

            const saveNewPlayer = async (newPlayerObj) => {
                jsonData.value.players.push(newPlayerObj);
                jsonData.value.last_update = new Date().toISOString().split('T')[0];
                await syncToCloud();
            };

            const updateSelectedPlayers = async (newList) => {
                selectedPlayers.value = newList;
                jsonData.value.current.list = newList.map(p => p.id);
                await syncToCloud();
            };
			
			const handleEditPlayer = async (updatedInfo) => {
                // 1. Update Master List
                const playerIndex = jsonData.value.players.findIndex(p => p.id === updatedInfo.id);
                if (playerIndex !== -1) {
                    jsonData.value.players[playerIndex].name = updatedInfo.name;
                    jsonData.value.players[playerIndex].gender = updatedInfo.gender;
                }

                // 2. Update Selected List
                const selectedIndex = selectedPlayers.value.findIndex(p => p.id === updatedInfo.id);
                if (selectedIndex !== -1) {
                    selectedPlayers.value[selectedIndex].name = updatedInfo.name;
                    selectedPlayers.value[selectedIndex].gender = updatedInfo.gender;
                }

                // 3. DEEP UPDATE: Update Active Schedule (The fix for the Game Tab)
                if (jsonData.value.current && jsonData.value.current.games) {
                    jsonData.value.current.games.forEach(round => {
                        // Update Players in Games
                        if (round.games) {
                            round.games.forEach(game => {
                                // Helper to update a specific player object
                                const updateObj = (p) => {
                                    if (p && p.id === updatedInfo.id) {
                                        p.name = updatedInfo.name;
                                        p.gender = updatedInfo.gender;
                                    }
                                };
                                
                                updateObj(game.pairA.p1);
                                updateObj(game.pairA.p2);
                                updateObj(game.pairB.p1);
                                updateObj(game.pairB.p2);
                            });
                        }
                        // Update Sitting Out Players
                        if (round.sitOuts) {
                            round.sitOuts.forEach(p => {
                                if (p.id === updatedInfo.id) {
                                    p.name = updatedInfo.name;
                                    p.gender = updatedInfo.gender;
                                }
                            });
                        }
                    });
                }
                
                // 4. Save to Cloud
                jsonData.value.last_update = new Date().toISOString().split('T')[0];
                await syncToCloud();
            };

			const handleSubstitutePlayer = async ({ oldId, newPlayer }) => {
				// 1. Update Selected List
				const selIndex = selectedPlayers.value.findIndex(p => p.id === oldId);
				if (selIndex !== -1) {
					selectedPlayers.value[selIndex] = newPlayer;
				}

				// 2. Update Current List IDs
				if(jsonData.value.current && jsonData.value.current.list) {
					const listIndex = jsonData.value.current.list.indexOf(oldId);
					if(listIndex !== -1) {
						jsonData.value.current.list[listIndex] = newPlayer.id;
					}
				}

				// 3. DEEP UPDATE: Replace in Games/Rounds
				// We must loop through Rounds -> Games -> PairA/PairB -> p1/p2
				if (jsonData.value.current && jsonData.value.current.games) {
					jsonData.value.current.games.forEach(round => {
						// Check Games
						if (round.games) {
							round.games.forEach(game => {
								// Helper to check and replace in a pair
								const checkAndReplace = (pair) => {
									if (pair.p1 && pair.p1.id === oldId) pair.p1 = newPlayer;
									if (pair.p2 && pair.p2.id === oldId) pair.p2 = newPlayer;
									// Recalculate strength (optional, but good practice)
									// Note: We'd need the getScore logic here to be precise, 
									// but updating the object is the critical part.
								};
								checkAndReplace(game.pairA);
								checkAndReplace(game.pairB);
							});
						}
						// Check Sit Outs
						if (round.sitOuts) {
							const sitIndex = round.sitOuts.findIndex(p => p.id === oldId);
							if (sitIndex !== -1) {
								round.sitOuts[sitIndex] = newPlayer;
							}
						}
					});
				}

				// 4. Save
				jsonData.value.last_update = new Date().toISOString().split('T')[0];
				await syncToCloud();
			};
			
			const handleFinalizeSession = async () => {
                // 1. Clear Active Games Schedule
                jsonData.value.current.games = [];
                jsonData.value.current.list = []; // Clear ID list
                
                // 2. Clear Local Selection
                selectedPlayers.value = [];

                // 3. Save to Cloud (This saves the cleared games AND the updated player ratios)
                jsonData.value.last_update = new Date().toISOString().split('T')[0];
                await syncToCloud();
            };

            // Helper to save current jsonData state to cloud
            const syncToCloud = async () => {
                isLoading.value = true;
                try {
                    await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_CONFIG.binId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Master-Key': JSONBIN_CONFIG.apiKey
                        },
                        body: JSON.stringify(jsonData.value)
                    });
                } catch (error) {
                    console.error("Error saving data:", error);
                    alert("Failed to save to cloud.");
                } finally {
                    isLoading.value = false;
                }
            };
			
			const saveGames = async (newSchedule) => {
				// 1. Update Local State
				jsonData.value.current.games = newSchedule;
				
				// 2. Update timestamp
				jsonData.value.last_update = new Date().toISOString().split('T')[0];

				// 3. Sync to Cloud
				await syncToCloud();
			};

            onMounted(() => {
                fetchData();
            });

            return {
                currentTab,
                tabs,
                jsonData,
                selectedPlayers,
                updateSelectedPlayers,
                saveNewPlayer,
				handleEditPlayer,
                fetchData,
				handleSubstitutePlayer,
				handleFinalizeSession,
                isLoading,
				saveGames,
				modalState,
                resolveModal,
                dialog
            };
        }
    }).mount('#app');
</script>

</body>
</html>